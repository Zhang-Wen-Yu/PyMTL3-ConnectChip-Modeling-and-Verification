//-------------------------------------------------------------------------
// Spi_Master_Warpped__pack_size_8__clks_per_half_bit_4.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL Component RegEn Definition
// At F:\python\lib\site-packages\pymtl3\stdlib\basic_rtl\registers.py

module RegEn__Type_8
(
  input  logic [0:0] clk ,
  input  logic [0:0] en ,
  input  logic [7:0] in_ ,
  output logic [7:0] out ,
  input  logic [0:0] reset 
);

  // PyMTL Update Block Source
  // At F:\python\lib\site-packages\pymtl3\stdlib\basic_rtl\registers.py:25
  // @update_ff
  // def up_regen():
  //   if s.en:
  //     s.out <<= s.in_
  
  always_ff @(posedge clk) begin : up_regen
    if ( en ) begin
      out <= in_;
    end
  end

endmodule


// PyMTL Component Spi_Master_Warpped Definition
// At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py

module Spi_Master_Warpped__pack_size_8__clks_per_half_bit_4
(
  input  logic [0:0] clk ,
  input  logic [0:0] reset ,
  output logic [0:0] master_ifc__cs  ,
  input logic [0:0] master_ifc__miso  ,
  output logic [0:0] master_ifc__mosi  ,
  output logic [0:0] master_ifc__sclk  ,
  input logic [7:0] req__msg  ,
  output logic [0:0] req__rdy  ,
  input logic [0:0] req__val  ,
  output logic [7:0] resp__msg  ,
  input logic [0:0] resp__rdy  ,
  output logic [0:0] resp__val  
);
  localparam logic [2:0] __const__clks_per_half_bit_at_state_transitions  = 3'd4;
  localparam logic [3:0] __const__pack_size_at_state_transitions  = 4'd8;
  localparam logic [2:0] __const__clks_per_half_bit_at_max_counter_values  = 3'd4;
  localparam logic [3:0] __const__pack_size_at_max_counter_values  = 4'd8;
  localparam logic [2:0] __const__clks_per_half_bit_at_generate_sclk  = 3'd4;
  localparam logic [3:0] __const__pack_size_at_mosi_shift_reg  = 4'd8;
  localparam logic [3:0] __const__pack_size_at_miso_shift_reg  = 4'd8;
  logic [5:0] cntr;
  logic [5:0] cntr_max;
  logic [7:0] miso_reg;
  logic [2:0] mosi_reg_pointer;
  logic [0:0] msg_from_slave;
  logic [0:0] result_read;
  logic [3:0] sclk_cntr;
  logic [0:0] sclk_en;
  logic [2:0] state;
  logic [0:0] val_progressing;
  //-------------------------------------------------------------
  // Component mosi_reg
  //-------------------------------------------------------------

  logic [0:0] mosi_reg__clk;
  logic [0:0] mosi_reg__en;
  logic [7:0] mosi_reg__in_;
  logic [7:0] mosi_reg__out;
  logic [0:0] mosi_reg__reset;

  RegEn__Type_8 mosi_reg
  (
    .clk( mosi_reg__clk ),
    .en( mosi_reg__en ),
    .in_( mosi_reg__in_ ),
    .out( mosi_reg__out ),
    .reset( mosi_reg__reset )
  );

  //-------------------------------------------------------------
  // End of component mosi_reg
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:80
  // @update
  // def cs_logic():
  //     if s.state == s.user_reset:
  //         s.master_ifc.cs @= 1
  //     if s.state == s.idle:
  //         s.master_ifc.cs @= 1
  //     if s.state == s.handshake:
  //         s.master_ifc.cs @= 0
  //     if s.state == s.transfer:
  //         s.master_ifc.cs @= 0
  //     if s.state == s.finish:
  //         s.master_ifc.cs @= 0
  //     if s.state == s.complete:
  //         s.master_ifc.cs @= 1
  
  always_comb begin : cs_logic
    if ( state == 3'd0 ) begin
      master_ifc__cs = 1'd1;
    end
    if ( state == 3'd1 ) begin
      master_ifc__cs = 1'd1;
    end
    if ( state == 3'd2 ) begin
      master_ifc__cs = 1'd0;
    end
    if ( state == 3'd3 ) begin
      master_ifc__cs = 1'd0;
    end
    if ( state == 3'd4 ) begin
      master_ifc__cs = 1'd0;
    end
    if ( state == 3'd5 ) begin
      master_ifc__cs = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:64
  // @update
  // def max_counter_values():
  //     if s.state == s.user_reset:
  //         s.cntr_max @= clks_per_half_bit
  //     if s.state == s.idle:
  //         s.cntr_max @= clks_per_half_bit
  //     if s.state == s.handshake:
  //         s.cntr_max @= clks_per_half_bit
  //     if s.state == s.transfer:
  //         s.cntr_max @= (2 * clks_per_half_bit * pack_size) - 1
  //     if s.state == s.finish:
  //         s.cntr_max @= clks_per_half_bit
  //     if s.state == s.complete:
  //         s.cntr_max @= clks_per_half_bit
  
  always_comb begin : max_counter_values
    if ( state == 3'd0 ) begin
      cntr_max = 6'( __const__clks_per_half_bit_at_max_counter_values );
    end
    if ( state == 3'd1 ) begin
      cntr_max = 6'( __const__clks_per_half_bit_at_max_counter_values );
    end
    if ( state == 3'd2 ) begin
      cntr_max = 6'( __const__clks_per_half_bit_at_max_counter_values );
    end
    if ( state == 3'd3 ) begin
      cntr_max = ( ( 3'd2 * 3'( __const__clks_per_half_bit_at_max_counter_values ) ) * 4'( __const__pack_size_at_max_counter_values ) ) - 7'd1;
    end
    if ( state == 3'd4 ) begin
      cntr_max = 6'( __const__clks_per_half_bit_at_max_counter_values );
    end
    if ( state == 3'd5 ) begin
      cntr_max = 6'( __const__clks_per_half_bit_at_max_counter_values );
    end
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:142
  // @update
  // def mosi_msb():
  //     s.master_ifc.mosi @= s.mosi_reg.out[s.mosi_reg_pointer]
  
  always_comb begin : mosi_msb
    master_ifc__mosi = mosi_reg__out[mosi_reg_pointer];
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:135
  // @update
  // def mosi_reg_en():
  //     if (s.state == s.idle) & (s.req.val == 1) :
  //         s.mosi_reg.en @= 1
  //     else:
  //         s.mosi_reg.en @= 0
  
  always_comb begin : mosi_reg_en
    if ( ( state == 3'd1 ) & ( req__val == 1'd1 ) ) begin
      mosi_reg__en = 1'd1;
    end
    else
      mosi_reg__en = 1'd0;
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:169
  // @update
  // def req_rdy():
  //     s.req.rdy @= s.resp.rdy & (s.state == s.idle)
  
  always_comb begin : req_rdy
    req__rdy = resp__rdy & ( state == 3'd1 );
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:210
  // @update
  // def resp_val():
  //     if (s.state == s.complete) & (s.result_read == 0) & (s.msg_from_slave == 1):
  //         s.resp.val @= 1
  //     elif (s.state == s.idle) & (s.result_read == 0) & (s.msg_from_slave == 1):
  //         s.resp.val @= 1
  //     else:
  //         s.resp.val @= 0
  
  always_comb begin : resp_val
    if ( ( ( state == 3'd5 ) & ( result_read == 1'd0 ) ) & ( msg_from_slave == 1'd1 ) ) begin
      resp__val = 1'd1;
    end
    else if ( ( ( state == 3'd1 ) & ( result_read == 1'd0 ) ) & ( msg_from_slave == 1'd1 ) ) begin
      resp__val = 1'd1;
    end
    else
      resp__val = 1'd0;
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:175
  // @update
  // def result_read():
  //     if s.state == s.user_reset:
  //         s.result_read @= 0
  //     if s.state == s.idle:
  //         if (s.result_read == 0) & (s.resp.rdy == 0):
  //             s.result_read @= 0
  //         else:
  //             s.result_read @= 1
  //     if s.state == s.handshake:
  //         s.result_read @= 0
  //     if s.state == s.transfer:
  //         s.result_read @= 0
  //     if s.state == s.finish:
  //         s.result_read @= 0
  //     if s.state == s.complete:
  //         if (s.resp.rdy == 1) & (s.cntr > 0):
  //             s.result_read @= 1
  
  always_comb begin : result_read
    if ( state == 3'd0 ) begin
      result_read = 1'd0;
    end
    if ( state == 3'd1 ) begin
      if ( ( result_read == 1'd0 ) & ( resp__rdy == 1'd0 ) ) begin
        result_read = 1'd0;
      end
      else
        result_read = 1'd1;
    end
    if ( state == 3'd2 ) begin
      result_read = 1'd0;
    end
    if ( state == 3'd3 ) begin
      result_read = 1'd0;
    end
    if ( state == 3'd4 ) begin
      result_read = 1'd0;
    end
    if ( state == 3'd5 ) begin
      if ( ( resp__rdy == 1'd1 ) & ( cntr > 6'd0 ) ) begin
        result_read = 1'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:96
  // @update
  // def sclk_logic():
  //     if s.state == s.transfer:
  //         s.sclk_en @= 1
  //     else:
  //         s.sclk_en @= 0
  
  always_comb begin : sclk_logic
    if ( state == 3'd3 ) begin
      sclk_en = 1'd1;
    end
    else
      sclk_en = 1'd0;
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:197
  // @update
  // def valid_resp():
  //     if s.state == s.user_reset:
  //         s.val_progressing @= 0
  //         s.msg_from_slave @= 0
  //     elif (s.state == s.idle) & (s.req.val == 1):
  //         s.val_progressing @= 1
  //         s.msg_from_slave @= 0
  //     elif (s.state == s.complete) & (s.val_progressing == 1):
  //         s.msg_from_slave @= 1
  //     else:
  //         s.val_progressing @= s.val_progressing
  
  always_comb begin : valid_resp
    if ( state == 3'd0 ) begin
      val_progressing = 1'd0;
      msg_from_slave = 1'd0;
    end
    else if ( ( state == 3'd1 ) & ( req__val == 1'd1 ) ) begin
      val_progressing = 1'd1;
      msg_from_slave = 1'd0;
    end
    else if ( ( state == 3'd5 ) & ( val_progressing == 1'd1 ) ) begin
      msg_from_slave = 1'd1;
    end
    else
      val_progressing = val_progressing;
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:104
  // @update_ff
  // def counter_logic():
  //     if s.state == s.idle:
  //         s.cntr <<= 0
  //     elif (s.cntr >= s.cntr_max) & (s.state != s.idle):
  //         s.cntr <<= 0
  //     else:
  //         s.cntr <<= s.cntr + 1
  
  always_ff @(posedge clk) begin : counter_logic
    if ( state == 3'd1 ) begin
      cntr <= 6'd0;
    end
    else if ( ( cntr >= cntr_max ) & ( state != 3'd1 ) ) begin
      cntr <= 6'd0;
    end
    else
      cntr <= cntr + 6'd1;
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:115
  // @update_ff
  // def generate_sclk():
  //     if s.sclk_en:
  //         if s.sclk_cntr == 0:
  //             s.master_ifc.sclk <<= ~s.master_ifc.sclk
  //             s.sclk_cntr <<= s.sclk_cntr + 1
  //         elif s.sclk_cntr == clks_per_half_bit - 1:
  //             s.master_ifc.sclk <<= s.master_ifc.sclk
  //             s.sclk_cntr <<= 0
  //         else:
  //             s.master_ifc.sclk <<= s.master_ifc.sclk
  //             s.sclk_cntr <<= s.sclk_cntr + 1
  //     else:
  //         s.master_ifc.sclk <<= 0
  //         s.sclk_cntr <<= 0
  
  always_ff @(posedge clk) begin : generate_sclk
    if ( sclk_en ) begin
      if ( sclk_cntr == 4'd0 ) begin
        master_ifc__sclk <= ~master_ifc__sclk;
        sclk_cntr <= sclk_cntr + 4'd1;
      end
      else if ( sclk_cntr == ( 4'( __const__clks_per_half_bit_at_generate_sclk ) - 4'd1 ) ) begin
        master_ifc__sclk <= master_ifc__sclk;
        sclk_cntr <= 4'd0;
      end
      else begin
        master_ifc__sclk <= master_ifc__sclk;
        sclk_cntr <= sclk_cntr + 4'd1;
      end
    end
    else begin
      master_ifc__sclk <= 1'd0;
      sclk_cntr <= 4'd0;
    end
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:158
  // @update_ff
  // def miso_shift_reg():
  //     if s.state == s.idle:
  //         s.miso_reg <<= 0
  //     if s.state == s.transfer:
  //         if (s.master_ifc.sclk == 0) & (s.sclk_cntr == 0):
  //             # [0:pack_size-1]: 0 means low bit,7 means high bit
  //             s.miso_reg <<= concat(s.miso_reg[0:pack_size - 1], s.master_ifc.miso)
  
  always_ff @(posedge clk) begin : miso_shift_reg
    if ( state == 3'd1 ) begin
      miso_reg <= 8'd0;
    end
    if ( state == 3'd3 ) begin
      if ( ( master_ifc__sclk == 1'd0 ) & ( sclk_cntr == 4'd0 ) ) begin
        miso_reg <= { miso_reg[3'd6:3'd0], master_ifc__miso };
      end
    end
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:145
  // @update_ff
  // def mosi_shift_reg():
  //     if s.state == s.idle:
  //         s.mosi_reg_pointer <<= pack_size - 1
  //     if s.state == s.transfer:
  //         if (s.master_ifc.sclk == 1) & (s.sclk_cntr == 0):
  //             if s.mosi_reg_pointer == 0:
  //                 s.mosi_reg_pointer <<= 0
  //             else:
  //                 s.mosi_reg_pointer <<= s.mosi_reg_pointer - 1
  
  always_ff @(posedge clk) begin : mosi_shift_reg
    if ( state == 3'd1 ) begin
      mosi_reg_pointer <= 4'( __const__pack_size_at_mosi_shift_reg ) - 4'd1;
    end
    if ( state == 3'd3 ) begin
      if ( ( master_ifc__sclk == 1'd1 ) & ( sclk_cntr == 4'd0 ) ) begin
        if ( mosi_reg_pointer == 3'd0 ) begin
          mosi_reg_pointer <= 3'd0;
        end
        else
          mosi_reg_pointer <= mosi_reg_pointer - 3'd1;
      end
    end
  end

  // PyMTL Update Block Source
  // At D:\Desktop\pModel-20220413\Module\SPI\SPIMaster\SpiMasterWarpped.py:41
  // @update_ff
  // def state_transitions():
  //     if s.reset:
  //         s.state <<= s.user_reset
  //     if s.state == s.user_reset:
  //         s.state <<= s.idle
  //     if s.state == s.idle:
  //         if s.resp.rdy & s.req.val:
  //             s.state <<= s.handshake
  //     if s.state == s.handshake:
  //         if s.cntr >= clks_per_half_bit:
  //             s.state <<= s.transfer
  //     if s.state == s.transfer:
  //         if s.cntr >= (2 * clks_per_half_bit * pack_size) - 1:
  //             s.state <<= s.finish
  //     if s.state == s.finish:
  //         if s.cntr >= clks_per_half_bit:
  //             s.state <<= s.complete
  //     if s.state == s.complete:
  //         if s.cntr >= clks_per_half_bit:
  //             s.state <<= s.idle
  
  always_ff @(posedge clk) begin : state_transitions
    if ( reset ) begin
      state <= 3'd0;
    end
    if ( state == 3'd0 ) begin
      state <= 3'd1;
    end
    if ( state == 3'd1 ) begin
      if ( resp__rdy & req__val ) begin
        state <= 3'd2;
      end
    end
    if ( state == 3'd2 ) begin
      if ( cntr >= 6'( __const__clks_per_half_bit_at_state_transitions ) ) begin
        state <= 3'd3;
      end
    end
    if ( state == 3'd3 ) begin
      if ( cntr >= ( ( ( 6'd2 * 6'( __const__clks_per_half_bit_at_state_transitions ) ) * 6'( __const__pack_size_at_state_transitions ) ) - 6'd1 ) ) begin
        state <= 3'd4;
      end
    end
    if ( state == 3'd4 ) begin
      if ( cntr >= 6'( __const__clks_per_half_bit_at_state_transitions ) ) begin
        state <= 3'd5;
      end
    end
    if ( state == 3'd5 ) begin
      if ( cntr >= 6'( __const__clks_per_half_bit_at_state_transitions ) ) begin
        state <= 3'd1;
      end
    end
  end

  assign mosi_reg__clk = clk;
  assign mosi_reg__reset = reset;
  assign mosi_reg__in_ = req__msg;
  assign resp__msg = miso_reg;

endmodule
